@inject IRoomChartViewModel ViewModel
@inject IStringLocalizer<Resource> Localizer
@inject PersistentComponentState ApplicationState
@inject ISnackbar Snackbar
@implements IDisposable

<h3>@RoomName</h3>

@if ((this.MinDate != null) && (this.MaxDate != null))
{

    <MudContainer Class="d-flex flex-row justify-start align-center gap-0 ml-0">
        <SelectDates MaxDate="@this.MaxDate" MinDate="@this.MinDate" @bind-StartDate=@StartDate @bind-EndDate=@EndDate></SelectDates>
        <MudButton Variant="Variant.Filled" Style="height:60px" OnClick="@this.DisplayChartsAsync" Color="MudBlazor.Color.Primary">@Localizer["DisplayCharts"]</MudButton>
    </MudContainer>
}

<RoomChartListView Models="@this.Models" ShouldRefresh="@this.ShouldRefresh"></RoomChartListView>

@code 
{
    private PersistingComponentStateSubscription persistingSubscription;

    private const string gamesDataKey = "GamesData";

    #region Properties

    private bool ShouldRefresh = true;

    public DateTime? StartDate { get; set; } = DateTime.Today;

    public DateTime? EndDate { get; set; } = DateTime.Today;

    public DateTime? MaxDate { get; set; }

    public DateTime? MinDate { get; set; }

    [Parameter]
    public string RoomId { get; set; } = string.Empty;

    [Parameter]
    public string RoomName { get; set; } = string.Empty;

    [Parameter]
    public string Location { get; set; } = string.Empty;

    public IEnumerable<RoomChartModel>? Models { get; set; }

    #endregion

    #region Methods

    protected override void OnInitialized()
    {
        persistingSubscription = ApplicationState.RegisterOnPersisting(PersistData);
    }

    protected override async Task OnParametersSetAsync()
    {
        if ((this.ViewModel != null) && (string.IsNullOrEmpty(this.RoomId) == false))
        {
            await this.ViewModel.InitializeAsync(this.Location);
            this.MaxDate = await this.ViewModel.GetRoomMaxDate(this.RoomId);
            this.MinDate = await this.ViewModel.GetRoomMinDate(this.RoomId);

            if (!ApplicationState.TryTakeFromJson<IEnumerable<RoomChartModel>>(gamesDataKey, out var restored))
            {
                this.Models = await this.ViewModel.GetChartsData(this.StartDate, this.EndDate, this.RoomId);
            }
            else
            {
                this.Models = restored;
            }
        }
    }
    private Task PersistData()
    {
        ApplicationState.PersistAsJson(gamesDataKey, this.Models);

        return Task.CompletedTask;
    }
    public void Dispose()
    {
        this.ViewModel?.Dispose();

        persistingSubscription.Dispose();
    }   
    public async Task DisplayChartsAsync()
    {
        this.ShouldRefresh = false;

        await Task.Delay(10);

        Task<IEnumerable<RoomChartModel>?> task = this.ViewModel.GetChartsData(this.StartDate, this.EndDate, this.RoomId);

        while (task.IsCompleted == false)
        {
            await Task.Delay(10);
        }

        if (task.IsCompleted)
        {
            this.ShouldRefresh = true;
            this.Models = await task;
        }
    }
    #endregion
}


